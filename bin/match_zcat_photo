#!/usr/bin/env python

"""Match data release redshift catalogs against the original photometric
(target) catalogs.

time /global/u2/i/ioannis/code/desihub/desispec/bin/match_zcat_photo --reduxdir /global/cfs/cdirs/desi/spectro/redux/fuji --mp 1 -o /global/cscratch1/sd/ioannis/photocatalog --overwrite


"""
import os, sys, argparse, pdb
from glob import glob
import numpy as np
import fitsio
import multiprocessing
from astropy.io import fits
from astropy.table import Table, vstack
from desispec.io import specprod_root
from desimodel.footprint import radec2pix

from desiutil.log import get_logger
log = get_logger()

desi_root = os.environ.get('DESI_ROOT')
fiberassign_dir = os.path.join(desi_root, 'target', 'fiberassign', 'tiles', 'trunk')

TARGETINGBITCOLS = [
    'CMX_TARGET',
    'DESI_TARGET', 'BGS_TARGET', 'MWS_TARGET',
    'SV1_DESI_TARGET', 'SV1_BGS_TARGET', 'SV1_MWS_TARGET',
    'SV2_DESI_TARGET', 'SV2_BGS_TARGET', 'SV2_MWS_TARGET',
    'SV3_DESI_TARGET', 'SV3_BGS_TARGET', 'SV3_MWS_TARGET',
    'SCND_TARGET',
    'SV1_SCND_TARGET', 'SV2_SCND_TARGET', 'SV3_SCND_TARGET',
    ]
    
# Fragile! Read a single row of a single target catalog in order to get the
# correct photometric data model. Add all the _TARGET columns at the end
datamodel = Table(fitsio.read('/global/cfs/cdirs/desi/target/catalogs/dr9/1.1.1/targets/main/resolve/dark/targets-dark-hp-0.fits', rows=0))
for col in datamodel.colnames:
    if '_TARGET' in col:
        datamodel.remove_column(col)
    else:
        datamodel[col] = np.zeros(datamodel[col].shape, dtype=datamodel[col].dtype)
for col in TARGETINGBITCOLS:
    datamodel[col] = np.zeros(1, dtype=np.int64)

def _cache_one_catalog(args):
    return cache_one_catalog(*args) 

def cache_one_catalog(cachefile):
    log.info('Reading and caching {}'.format(cachefile))
    if '.ecsv' in cachefile:
        cat = Table.read(cachefile)
        if 'sv3' in cachefile:
            key = 'TOO_sv3'
        else:
            key = 'TOO_main'
    else:
        cat = Table(fitsio.read(cachefile))
        key = cachefile
    return {key: cat}

def _targets_one_healpix(args):
    return

def _targets_one_tile(args):
    return targets_one_tile(*args)

def targets_one_healpix():
    return

def targets_one_tile(tileid, zcat, photocache, reduxdir, coadd_type, checkfiles=False):
    """Build the photometric target catalog for all the objects on a single tile."""

    # check that the spectra exist as a validation step
    if checkfiles:
        assert(len(np.unique(zcat['LASTNIGHT'])) == 1) # unique?
        lastnight = str(zcat['LASTNIGHT'][0])
        for petal in set(zcat['PETAL_LOC']):
            coaddfile = os.path.join(reduxdir, 'tiles', coadd_type, str(tileid), lastnight,
                                     'coadd-{}-{}-thru{}.fits'.format(str(petal), tileid, lastnight))
            redrockfile = os.path.join(reduxdir, 'tiles', coadd_type, str(tileid), lastnight,
                                       'redrock-{}-{}-thru{}.fits'.format(str(petal), tileid, lastnight))
            if not os.path.isfile(coaddfile):
                log.info('Missing {}'.format(coaddfile))
            if not os.path.isfile(redrockfile):
                log.info('Missing {}'.format(redrockfile))
    
    # build the full photometric catalog
    targetdirs, TOO = get_targetdirs(tileid, photocache)

    out = read_target_photo(zcat, photocache, targetdirs, TOO=TOO)

    return out

def get_targetdirs(tileid, photocache):
    """Get the targets catalog used to build a given fiberassign catalog."""
    stileid = '{:06d}'.format(tileid)
    fiberfile = os.path.join(fiberassign_dir, stileid[:3], 'fiberassign-{}.fits.gz'.format(stileid))
    if not os.path.isfile(fiberfile):
        fiberfile = fiberfile.replace('.gz', '')
        if not os.path.isfile(fiberfile):
            log.warning('Fiber assignment file {} not found!'.format(fiberfile))
    log.info('Reading {} header.'.format(fiberfile))
    # old versions of fitsio can't handle CONTINUE header cards!
    #fahdr = fitsio.read_header(fiberfile, ext=0)
    fahdr = fits.getheader(fiberfile, ext=0)
    targetdirs = [fahdr['TARG']]
    for moretarg in ['TARG2', 'TARG3', 'TARG4']:
        if moretarg in fahdr:
            if 'gaia' not in fahdr[moretarg]: # skip
                targetdirs += [fahdr[moretarg]]
    if 'SCND' in fahdr:
        if fahdr['SCND'].strip() != '-':
            targetdirs += [fahdr['SCND']]

    for ii, targetdir in enumerate(targetdirs):
        # for secondary targets, targetdir can be a filename
        if targetdir[-4:] == 'fits': # fragile...
            targetdir = os.path.dirname(targetdir)
        if not os.path.isdir(targetdir):
            # can be a KPNO directory!
            if 'DESIROOT' in targetdir:
                targetdir = os.path.join(desi_root, targetdir.replace('DESIROOT/', ''))
            if targetdir[:6] == '/data/':
                targetdir = os.path.join(desi_root, targetdir.replace('/data/', ''))
            
        if os.path.isdir(targetdir):
            log.info('Found targets directory {}'.format(targetdir))
            targetdirs[ii] = targetdir
        else:
            log.warning('Targets directory {} not found.'.format(targetdir))
            continue

    # any ToOs?
    if 'TOO' in fahdr:
        # special case, fragile!
        if 'sv3' in fahdr['TOO']:
            TOO = photocache['TOO_sv3']
        else:
            TOO = photocache['TOO_main']
    else:
        TOO = None
        
    return targetdirs, TOO

def read_target_photo(zcat, photocache, targetdirs, TOO=None):
    """For a given tile, given a set of target directories and (optionally) a
    TOOfile used to build the set of targets, read and stack all the photometric
    targeting information for all objects.

    """
    # initialize the output catalog
    out = Table(np.hstack(np.repeat(datamodel, len(zcat))))
    out['TARGETID'] = zcat['TARGETID']
    
    photo, photofiles = [], []
    for targetdir in set(np.hstack(targetdirs)):
        # Handle secondary targets, which have a different data model;
        # update on 2021 July 31: these catalogs are missing DR9
        # photometry, so we have to skip them for now.
        if 'secondary' in targetdir:
            #continue                    
            if 'sv1' in targetdir: # special case
                if 'dedicated' in targetdir:
                    targetfiles = glob(os.path.join(targetdir, 'DC3R2_GAMA_priorities.fits'))
                else:
                    targetfiles = glob(os.path.join(targetdir, '*-secondary-dr9photometry.fits'))
            else:
                targetfiles = glob(os.path.join(targetdir, '*-secondary.fits'))
        else:
            targetfiles = glob(os.path.join(targetdir, '*-hp-*.fits'))
            filenside = fitsio.read_header(targetfiles[0], ext=1)['FILENSID']
            # https://github.com/desihub/desispec/issues/1711
            if np.any(np.isnan(zcat['TARGET_RA'])): # some SV1 targets have nan in RA,DEC
                log.warning('Some RA, DEC are NaN in target directory {}'.format(targetdir))
            notnan = np.isfinite(zcat['TARGET_RA'])
            if np.sum(notnan) > 0:
                pixlist = radec2pix(filenside, zcat['TARGET_RA'][notnan], zcat['TARGET_DEC'][notnan])
                targetfiles = [targetfiles[0].split('hp-')[0]+'hp-{}.fits'.format(pix) for pix in set(pixlist)]
            else:
                targetfiles = []

        if len(targetfiles) == 0:
            continue

        #print(targetfiles)
        for ifile, targetfile in enumerate(targetfiles):
            # If this is a secondary target catalog, use the cache. Also note
            # that secondary target catalogs are missing some or all of the DR9
            # photometry columns we need, so only copy what exists, e.g.,
            #   /global/cfs/cdirs/desi/spectro/redux/everest/healpix/sv3/bright/153/15343/redrock-sv3-bright-15343.fits
            if targetfile in photocache.keys():
                I = np.where(np.isin(photocache[targetfile]['TARGETID'], zcat['TARGETID']))[0]
                log.info('Matched {} targets in {}'.format(len(I), targetfile))
                if len(I) > 0:
                    cachecat = photocache[targetfile][I]
                    _photo = Table(np.hstack(np.repeat(datamodel, len(I))))
                    for col in _photo.colnames: # not all these columns will exist...
                        if col in cachecat.colnames:
                            _photo[col] = cachecat[col]
                    photofiles.append(targetfile)
                    photo.append(_photo)
                continue

            # get the correct extension name or number
            tinfo = fitsio.FITS(targetfile)
            for _tinfo in tinfo:
                extname = _tinfo.get_extname()
                if 'TARGETS' in extname:
                    break
            if extname == '':
                extname = 1
                
            # fitsio does not preserve the order of the rows but we'll sort later.
            photo_targetid = tinfo[extname].read(columns='TARGETID')
            I = np.where(np.isin(photo_targetid, zcat['TARGETID']))[0]
            #if len(I) == 0:
            #    log.warning('No matching targets!')
            #    raise ValueError
            
            log.info('Matched {} targets in {}'.format(len(I), targetfile))
            if len(I) > 0:
                photo1 = tinfo[extname].read(rows=I)
                # Columns can be out of order, so sort them here based on the
                # data model so we can stack below.
                _photo = Table(np.hstack(np.repeat(datamodel, len(I))))
                for col in _photo.colnames: # all these columns should exist...
                    if col in photo1.dtype.names:
                        _photo[col] = photo1[col]
                    #else:
                    #    log.info('Skipping missing column {} from {}'.format(col, targetfile))
                del photo1
                photofiles.append(targetfile)
                photo.append(_photo)

    # handle ToO targets
    if TOO is not None:
        I = np.where(np.isin(TOO['TARGETID'], zcat['TARGETID']))[0]
        log.info('Matched {} TOO targets'.format(len(I)))
        if len(I) > 0:
            cachecat = TOO[I]
            _photo = Table(np.hstack(np.repeat(datamodel, len(I))))
            for col in _photo.colnames: # not all these columns will exist...
                if col in cachecat.colnames:
                    _photo[col] = cachecat[col]
            photofiles.append('TOO')
            photo.append(_photo)

    # backup programs have no target catalog photometry at all
    if len(photo) == 0:
        log.warning('No photometry found at all!')
        #raise ValueError
        #pdb.set_trace()
        photo = [out]

    # np.hstack will sometimes complain even if the tables are identical...
    #photo = Table(np.hstack(photo))
    photo = vstack(photo)
    #for col in photo[0].colnames:
    #    if not photo[0][col].dtype == photo[1][col].dtype:
    #        log.warning('Mismatching dtype in column {}'.format(col))

    # make sure there are no duplicates...?
    _, uindx = np.unique(photo['TARGETID'], return_index=True) 
    photo = photo[uindx]
    assert(len(np.unique(photo['TARGETID'])) == len(photo))

    # sort explicitly in order to ensure order
    I = np.where(np.isin(out['TARGETID'], photo['TARGETID']))[0]
    srt = np.hstack([np.where(tid == photo['TARGETID'])[0] for tid in out['TARGETID'][I]])
    out[I] = photo[srt]
    
    ## photometric columns can be out of order...
    #for col in photo.colnames:
    #    #print(col)
    #    out[col][I] = photo[srt][col]

    return out

def main():

    p = argparse.ArgumentParser()
    p.add_argument('--reduxdir', type=str, help='spectro redux base dir overrides $DESI_SPECTRO_REDUX/$SPECPROD')
    p.add_argument('-o', '--outdir', type=str, required=True, help='output directory file')
    p.add_argument('--mp', type=int, default=1, help='number of multiprocessing cores')
    p.add_argument('--overwrite', action='store_true', help='Overwrite an existing file.')
    
    args = p.parse_args()
    log = get_logger()

    if args.reduxdir is None:
        args.reduxdir = specprod_root()

    if not os.path.isdir(args.outdir):
        os.makedirs(args.outdir, exist_ok=True)

    # for testing
    rand = np.random.RandomState(seed=1)

    # figure out which secondary target catalogs actually were used to design tiles
    get_secondary_targetdirs = False
    if get_secondary_targetdirs:
        fiberfiles = np.hstack(glob(os.path.join(fiberassign_dir, '???', 'fiberassign-*.fits*')))
        #I = rand.choice(len(fiberfiles), size=50, replace=False) # for testing
        #fiberfiles = fiberfiles[I]
        targetdirs = []
        for ii, fiberfile in enumerate(fiberfiles):
            if ii % 500 == 0:
                log.info('Working on fiberfile {}/{}'.format(ii, len(fiberfiles)))
            fahdr = fits.getheader(fiberfile, ext=0)        
            if 'SCND' in fahdr:
                if fahdr['SCND'].strip() != '-':
                    targetdirs += [fahdr['SCND']]
        targetdirs = np.unique(np.hstack(targetdirs))
        final_targetdirs = []
        for ii, targetdir in enumerate(targetdirs):
            # can be a KPNO directory!
            if 'DESIROOT' in targetdir:
                targetdir = os.path.join(desi_root, targetdir.replace('DESIROOT/', ''))
            if targetdir[:6] == '/data/':
                targetdir = os.path.join(desi_root, targetdir.replace('/data/', ''))
            if os.path.isdir(targetdir):
                targetdir = glob(os.path.join(targetdir, '*.fits'))
            for targetdir1 in np.atleast_1d(targetdir):                
                if os.path.isfile(targetdir1):
                    log.info('Found secondary targets catalog {}'.format(targetdir1))
                    final_targetdirs.append(targetdir1)
                else:
                    log.warning('Targets directory {} not found.'.format(targetdir))
        log.info(np.unique(final_targetdirs))
    
    # To speed things up, read and cache all the large secondary target catalogs and
    # the TOO files *once*. Now, not all these catalogs are actually used but we
    # don't know which ones yet until we read all the fiberassign headers.
    ##print('Hack! Only read one secondary catalog!')
    #cachefiles = np.hstack([
    #    glob('/global/cfs/cdirs/desi/target/catalogs/dr9/*/targets/*/secondary/*/*targets-*-secondary*.fits'),
    #    #glob('/global/cfs/cdirs/desi/target/catalogs/dr9/1.0.0/targets/main/secondary/dark/*targets-*-secondary*.fits'),
    #    glob('/global/cfs/cdirs/desi/survey/ops/surveyops/trunk/mtl/*/ToO/ToO.ecsv')
    #    ])

    #cachefiles = np.hstack([
    #    ['/global/cfs/cdirs/desi/target/catalogs/dr9/0.48.0/targets/sv1/secondary/dark/sv1targets-dark-secondary-dr9photometry.fits',
    #     #'/global/cfs/cdirs/desi/target/catalogs/dr9/0.48.0/targets/sv1/secondary/dark/sv1targets-dark-secondary.fits',
    #     '/global/cfs/cdirs/desi/target/catalogs/dr9/0.50.0/targets/sv1/secondary/bright/sv1targets-bright-secondary-dr9photometry.fits',
    #     #'/global/cfs/cdirs/desi/target/catalogs/dr9/0.50.0/targets/sv1/secondary/bright/sv1targets-bright-secondary.fits',
    #     '/global/cfs/cdirs/desi/target/catalogs/dr9/0.50.0/targets/sv1/secondary/dark/sv1targets-dark-secondary-dr9photometry.fits',
    #     #'/global/cfs/cdirs/desi/target/catalogs/dr9/0.50.0/targets/sv1/secondary/dark/sv1targets-dark-secondary.fits',
    #     '/global/cfs/cdirs/desi/target/catalogs/dr9/0.51.0/targets/sv1/secondary/dark/sv1targets-dark-secondary-dr9photometry.fits',
    #     #'/global/cfs/cdirs/desi/target/catalogs/dr9/0.51.0/targets/sv1/secondary/dark/sv1targets-dark-secondary.fits',
    #     '/global/cfs/cdirs/desi/target/catalogs/dr9/0.52.0/targets/sv1/secondary/dark/sv1targets-dark-secondary-dr9photometry.fits',
    #     #'/global/cfs/cdirs/desi/target/catalogs/dr9/0.52.0/targets/sv1/secondary/dark/sv1targets-dark-secondary.fits',
    #     '/global/cfs/cdirs/desi/target/catalogs/dr9/0.57.0/targets/sv3/secondary/bright/sv3targets-bright-secondary.fits',
    #     '/global/cfs/cdirs/desi/target/catalogs/dr9/0.57.0/targets/sv3/secondary/dark/sv3targets-dark-secondary.fits',
    #     '/global/cfs/cdirs/desi/target/catalogs/dr9/1.0.0/targets/main/secondary/bright/targets-bright-secondary.fits',
    #     '/global/cfs/cdirs/desi/target/catalogs/dr9/1.0.0/targets/main/secondary/dark/targets-dark-secondary.fits',
    #     '/global/cfs/cdirs/desi/target/catalogs/dr9/1.1.1/targets/main/secondary/bright/targets-bright-secondary.fits',
    #     '/global/cfs/cdirs/desi/target/catalogs/dr9/1.1.1/targets/main/secondary/dark/targets-dark-secondary.fits',
    #     '/global/cfs/cdirs/desi/target/secondary/sv1/dedicated/0.49.0/DC3R2_GAMA_priorities.fits'],
    #    glob('/global/cfs/cdirs/desi/survey/ops/surveyops/trunk/mtl/*/ToO/ToO.ecsv')
    #    ])
    
    cachefiles = np.hstack(glob('/global/cfs/cdirs/desi/survey/ops/surveyops/trunk/mtl/*/ToO/ToO.ecsv'))
    
    mpargs = []
    for cachefile in cachefiles:
        if cachefile.replace('.fits', '-dr9photometry.fits') in cachefiles and '.ecsv' not in cachefile: # just read the photometry
            continue
        mpargs.append([cachefile])
        
    if args.mp > 1:
        with multiprocessing.Pool(args.mp) as P:
            photocache1 = P.map(_cache_one_catalog, mpargs)
    else:
        photocache1 = [cache_one_catalog(mparg[0]) for mparg in mpargs]
    
    photocache = {}
    for _photocache1 in photocache1:
        photocache.update(_photocache1)
        
    # handle the ztile catalogs
    basecolumns = ['TARGETID', 'TILEID', 'PETAL_LOC', 'TARGET_RA', 'TARGET_DEC']
    
    zprefix = 'ztile'
    #for coadd_type in ['pernight']:
    for coadd_type in ['cumulative', 'perexp', 'pernight']:
        log.info('Working on coadd type {}'.format(coadd_type))
        zcatfiles = sorted(set(glob(os.path.join(args.reduxdir, 'zcatalog', '{}-*-{}.fits'.format(zprefix, coadd_type)))))
        #print('Hack!')
        #pdb.set_trace()
        #zcatfiles = [zcatfiles[3]]
        #zcatfiles = ['/global/cfs/cdirs/desi/spectro/redux/fuji/zcatalog/ztile-special-dark-{}.fits'.format(coadd_type)]
        for zcatfile in zcatfiles:
            log.info('Working on redshift catalog {}'.format(zcatfile))
            outfile = os.path.join(args.outdir, os.path.basename(zcatfile).replace('{}-'.format(zprefix), '{}-photo-'.format(zprefix)))
            if os.path.isfile(outfile) and not args.overwrite:
                log.info('Output file {} exists; use --overwrite'.format(outfile))
                continue

            if coadd_type == 'cumulative':
                columns = basecolumns + ['LASTNIGHT']
            elif coadd_type == 'perexp':
                columns = basecolumns + ['NIGHT', 'EXPID']
            elif coadd_type == 'pernight':
                columns = basecolumns + ['NIGHT']

            zcat = Table(fitsio.read(zcatfile, 'ZCATALOG', columns=columns))
                
            #print('Hack to just one tile!')
            #zcat = zcat[zcat['TILEID'] == 81108]
            J = rand.choice(len(zcat), size=100, replace=False)
            zcat = zcat[J]
            
            # multiprocess over tiles
            mpargs = [[tileid, zcat[tileid == zcat['TILEID']], photocache, args.reduxdir, coadd_type, False] for tileid in set(zcat['TILEID'])]
            if args.mp > 1:
                with multiprocessing.Pool(args.mp) as P:
                    out = P.map(_targets_one_tile, mpargs)
            else:
                out = [targets_one_tile(*mparg) for mparg in mpargs]

            # stack and write out
            out = Table(np.hstack(out))
            srt = np.hstack([np.where(tid == out['TARGETID'])[0] for tid in zcat['TARGETID']])
            out = out[srt]

            try:
                assert(np.all(out['TARGETID'] == zcat['TARGETID']))
            except:
                pdb.set_trace()
                
            out.meta['EXTNAME'] = 'ZPHOT'
            log.info('Writing {} objects to {}'.format(len(out), outfile))
            out.write(outfile, overwrite=True)

    pdb.set_trace()
    
    # handle the zpix catalogs
    zprefix = 'zpix'
    zcatfiles = sorted(set(glob(os.path.join(args.reduxdir, 'zcatalog', '{}-*.fits'.format(zprefix)))))
    #zcatfiles = ['/global/cfs/cdirs/desi/spectro/redux/fuji/zcatalog/ztile-special-dark-cumulative.fits']
    for zcatfile in zcatfiles:
        outfile = os.path.join(args.outdir, os.path.basename(zcatfile).replace('{}-'.format(zprefix), '{}-photo-'.format(zprefix)))        
        if os.path.isfile(outfile) and not args.overwrite:
            log.info('Output file {} exists; use --overwrite'.format(outfile))
            continue
        
        zcat = Table(fitsio.read(zcatfile, 'ZCATALOG', columns=['TARGETID', 'HEALPIX', 'TARGET_RA', 'TARGET_DEC']))
        # multiprocess over healpixels
        mpargs = [[healpix, zcat[healpix == zcat['HEALPIX']], photocache, args.reduxdir] for healpix in set(zcat['HEALPIX'])]
        if args.mp > 1:
            with multiprocessing.Pool(args.mp) as P:
                out = P.map(_targets_one_healpix, mpargs)
        else:
            out = [targets_one_healpix(*mparg) for mparg in mpargs]

        # stack and write out
        out = Table(np.hstack(out))
        assert(np.all(out['TARGETID'] == zcat['TARGETID']))
        out.meta['EXTNAME'] = 'ZPHOT'
        log.info('Writing {} objects to {}'.format(len(out), outfile))
        out.write(outfile, overwrite=True)

        pdb.set_trace()
        
if __name__ == '__main__':
    main()
