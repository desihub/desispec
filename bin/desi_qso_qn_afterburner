#!/usr/bin/env python
# coding: utf-8

import os
import sys

import argparse

import fitsio
import numpy as np
import pandas as pd

from desiutil.log import get_logger

from redrock.templates import find_templates
from redrock.external.desi import rrdesi

from quasarnp.io import load_model, load_desi_coadd
from quasarnp.utils import process_preds

log = get_logger()


## LOAD template to RE-RUN redrock
qso_template_filename = [path for path in find_templates() if os.path.basename(path) == 'rrtemplate-qso.fits'][0]

try: # check if the env variable QN_MODEL_FILE is defined, otherwise load boss_dr12/qn_train_coadd_indtrain_0_0_boss10.h5
     model_QN_path = os.environ['QN_MODEL_FILE']
except KeyError:
    model_QN_path = "/global/cfs/cdirs/desi/science/lya/qn_models/boss_dr12/qn_train_coadd_indtrain_0_0_boss10.h5"
model_QN = load_model(model_QN_path)

def collect_argparser():
    parser = argparse.ArgumentParser(description="Run QN and rerun RR on a coadd file to find true quasars with correct redshift")

    parser.add_argument("--coadd", type=str, required=True,
                        help="coadd file containing spectra")
    parser.add_argument("--zbest", type=str, required=True,
                        help="zbest file associated (in the same folder) to the coadd file")
    parser.add_argument("--output", type=str, required=True,
                        help="output filename where the result of the MgII will be saved")

    parser.add_argument("--target_version", type=str, required=False, default="MAIN",
                        help="give the name of the target version: SV1 / SV3 / MAIN ")

    # for QN
    parser.add_argument("--c_thresh", type=float, required=False, default=0.5,
                        help="For QN: is_qso_QN =  np.sum(c_line > c_thresh, axis=0) >= n_thresh")
    parser.add_argument("--n_thresh", type=int, required=False, default=1,
                        help="For QN: is_qso_QN =  np.sum(c_line > c_thresh, axis=0) >= n_thresh")

    # for RR
    parser.add_argument("--template", type=str, required=False, default=qso_template_filename,
                        help="give the RR template for the new RR run, by default:redrock_qso_template")
    parser.add_argument("--filename_priors", type=str, required=False, default='priors-tmp.fits',
                        help="filename for the RR prior file, by default:priors-tmp.fits")
    parser.add_argument("--filename_output_rerun_RR", type=str, required=False, default="redrock-tmp.h5",
                        help="filename for the output of the new run of RR, by default:redrock-tmp.h5")
    parser.add_argument("--filename_zbest_rerun_RR", type=str, required=False, default="zbest-tmp.fits",
                        help="filename for the zbest file of the new run of RR, by default:zbest-tmp.fits")
    parser.add_argument("--delete_RR_output", type=str, required=False, default='True',
                        help="delete RR outputs: True or False, they are useless since everything usefull are saved in output, by defaut:True")

    return parser.parse_args()


def collect_redshift_with_new_RR_run(spectra_name, targetid, z_prior, param_RR):

    """
    Wrapper to run Redrock on targetid (numpy array) from the spectra_name_file
    with z_prior using the template contained in template_file
    Args:
        spectra_name (str): The name of the spectra file.
        targetid (int array): array of the targetid (contained in the spectra_name_file)
                              on which RR will be rerun with prior and qso template.
        z_prior (float array): array of the same size than targetid with the
                               redshift estimated by QN for the associated targetid
        param_RR (dict): contains info to re-run RR as the template_filename,
                        filename_priors, filename_output_rerun_RR, filename_zbest_rerun_RR

    Returns:
        redshift (numpy array): Array containing best redshift estimation by the new run of RR
        err_redshift (numpy array): Array containing the associated error for the redshift
        coeffs (list): List containing the coefficient for the best fit given by RR
                       even we work only with QSO template, it has a "shape" (not real shape since it is a list)
                       of redshift.size x 10
                       WARNING: they are converted to list (with .tolist()) to be added in the pandas dataframe
    """


    template_filename = param_RR['template_filename']
    filename_priors =  param_RR['filename_priors']
    filename_output_rerun_RR =  param_RR['filename_output_rerun_RR']
    filename_zbest_rerun_RR = param_RR['filename_zbest_rerun_RR']

    def write_prior_for_RR(targetid, z_prior, filename_priors):
         """
         Write the prior file for RR associated to the targetid list
         Args:
            targetid (int array): array of the targetid
                                  on which RR will be rerun with prior and qso template.
            z_prior (float array): array of the same size than targetid with the
                                   redshift estimated by QN for the associated targetid
            filename_priors (str): name under which the file will be saved
         Returns:
            NONE
         """

        function = np.array(['tophat'] * z_prior.size) #need to be the same for every one
        sigma = 0.1*np.ones(z_prior.size)
        # save
        out = fitsio.FITS(filename_priors, 'rw', clobber=True)
        data, names, extname = [targetid, function, z_prior, sigma], ['TARGETID', 'FUNCTION', 'Z', 'SIGMA'], 'PRIORS'
        out.write(data, names=names, extname=extname)
        out.close()
        log.debug(f'Write prior file for RR with {z_prior.size} objetcs: {filename_priors}')

    def extract_redshift_info_from_RR():
         """
         extract information of the zbest file from the new RR run
         Args:
             filename_zbest (str): Name of the zbest file from the new run of RR
         Returns:
            redshift (numpy array): Array containing best redshift estimation by the new run of RR
            err_redshift (numpy array): Array containing the associated error for the redshift
            coeffs (list): List containing the coefficient for the best fit given by RR
                           even we work only with QSO template, it has a "shape" (not real shape since it is a list)
                           of redshift.size x 10
                           WARNING: they are converted to list (with .tolist()) to be added in the pandas dataframe
         """
        with fitsio.FITS(filename_zbest) as zbest:
            redshift = zbest[1]['Z'][:]
            err_redshift = zbest[1]['ZERR'][:]
            coeffs = np.zeros((redshift.size, 10))
            coeffs[:, :4] = zbest[1]['COEFF'][:]
        return redshift, err_redshift, coeffs.tolist()

    write_prior_for_RR(targetid, z_prior, filename_priors)

    argument_for_rerun_RR = [spectra_name,
                             '--templates', template_filename,
                             '--targetids', ",".join(targetid.astype(str)),
                             '--priors', filename_priors,
                             '--output', filename_output_rerun_RR,
                             '--zbest', filename_zbest_rerun_RR]
    # NEW RUN RR
    rrdesi(argument_for_rerun_RR)

    # Extract information from the new run of RR
    redshift, err_redshift, coeffs = extract_redshift_info_from_RR(filename_zbest_rerun_RR)

    if param_RR['delete_RR_output'] == 'True':
        log.debug("Remove output from the new run of RR")
        os.remove(filename_priors)
        os.remove(filename_output_rerun_RR)
        os.remove(filename_zbest_rerun_RR)

    return redshift, err_redshift, coeffs


def selection_targets_with_QN(zbest, fibermap, index_sorted, sel_to_QN, spectra_name, param_QN, param_RR):
    """
    Run QuasarNet to the object with index_to_QN == True from spectra_name.
    Then, Re-Run RedRock for the targetids which are selected by QN as a QSO.
    Args:
        zbest: fitsio hdu 'ZBEST' from zbest file
        fibermap:  fitsio hdu 'FIBERMAP' from zbest file
        index_sorted (int array): index to have fibermap[index_sorted] in the same order than zbest
                      it is build with the TARGETID increasing
        sel_to_QN (bool array): size 500. Select on which objects QN will be apply (index based on zbest)
        spectra_name (str): The name of the spectra file
        param_QN (dict): contains info for QN as n_thresh and c_thresh
        param_RR (dict): contains info to re-run RR as the template_filename,
                        filename_priors, filename_output_rerun_RR, filename_zbest_rerun_RR
    Returns:
        QSO_sel (pandas dataframe): contains all the information useful to build the QSO cat
    """


    ## INFO FOR QUASAR NET
    lines = ['LYA','CIV(1548)','CIII(1909)', 'MgII(2796)','Hbeta','Halpha']
    lines_bal = ['CIV(1548)']

    data, index_with_QN = load_desi_coadd(spectra_name, sel_to_QN)

    if len(index_with_QN) == 0: # if there is no object for QN :(
        QSO_sel = pd.DataFrame()
    else:
        p = model_QN.predict(data[:, :, None])
        c_line, z_line, zbest_QN, c_line_bal, z_line_bal = process_preds(p, lines, lines_bal, verbose=False) # c_line.size = index_with_QN.size and not index_to_QN !!

        # Selection QSO with QN :
        # sel_index_with_QN.size = zbest_QN.size = index_with_QN.size | is_qso_QN.size = index_to_QN.size | sel_QN.size = 500
        log.info(f"We select QSO from QN with c_thresh={param_QN['c_thresh']} and n_thresh={param_QN['n_thresh']}")
        sel_index_with_QN = np.sum(c_line > param_QN['c_thresh'], axis=0) >= param_QN['n_thresh']
        is_qso_QN = np.zeros(sel_to_QN.sum(), dtype=bool)
        is_qso_QN[index_with_QN] = sel_index_with_QN
        sel_QN = sel_to_QN.copy()
        sel_QN[sel_to_QN] = is_qso_QN

        log.info("Remove objetcs with SPECTYPE==QSO and |z_RR - z_QN| < 0.1")
        sel_QSO_RR_with_z_pb = (zbest['SPECTYPE'][:] == 'QSO')
        sel_QSO_RR_with_z_pb[sel_QN] &= np.abs(zbest['Z'][:][sel_QN] - zbest_QN[sel_index_with_QN]) <= 0.1

        sel_QN &= ~sel_QSO_RR_with_z_pb
        index_with_QN_with_pb = sel_QN[sel_to_QN][index_with_QN]

        log.info(f"RUN RR on {sel_QN.sum()}")
        if sel_QN.sum() == 0: # If there is no quasar we don't apply RR: error with RR if targetid == ''
            QSO_sel = pd.DataFrame()
        else:
            # Re-run Redrock with prior and with only qso templates to compute the redshift of QSO_QN
            redshift, err_redshift, coeffs = collect_redshift_with_new_RR_run(spectra_name, zbest['TARGETID'][:][sel_QN], zbest_QN[index_with_QN_with_pb], param_RR)

            QSO_sel = pd.DataFrame()
            QSO_sel['TARGETID'] = zbest['TARGETID'][:][sel_QN]
            QSO_sel['RA'] = fibermap['TARGET_RA'][:500][index_sorted][sel_QN]
            QSO_sel['DEC'] = fibermap['TARGET_DEC'][:500][index_sorted][sel_QN]

            QSO_sel['Z'] = redshift
            QSO_sel['ZERR'] = err_redshift
            QSO_sel['COEFFS'] = coeffs

            QSO_sel['SPECTYPE'] = zbest['SPECTYPE'][:][sel_QN]
            QSO_sel['Z_RR'] = zbest['Z'][:][sel_QN]
            QSO_sel['Z_QN'] = zbest_QN[index_with_QN_with_pb]
            QSO_sel['C_LINES'] = c_line.T[index_with_QN_with_pb].tolist()
            QSO_sel['Z_LINES'] = z_line.T[index_with_QN_with_pb].tolist()

    return QSO_sel


def save_dataframe_to_fits(dataframe, filename, DESI_TARGET, clobber=True):
    """
    Save info from pandas dataframe in a fits file. Need to write the dtype array
    because of the list in the pandas dataframe (no other solution found)
    Args:
        dataframe (pandas dataframe): dataframe containg the all the necessary QSO info
        filename (str):  name of the fits file
        DESI_TARGET (str): name of DESI_TARGET for the wanted version of the target selection
        clobber (bool): overwrite the fits file defined by filename ?
    Returns:
        None
    """
    # Ok we cannot use dataframe.to_records() car les coeffs/c_lines sont sauvegarder sous forme de list de type objet et ne peux pas etre convertit ..
    data = np.zeros(dataframe.shape[0], dtype=[('TARGETID', 'i8'), ('RA','f8'), ('DEC','f8'), ('Z','f8'), ('ZERR', 'f4'),
                                               ('COEFFS', ('f4', 10)), ('SPECTYPE', 'U10'), ('Z_RR', 'f4'), ('Z_QN', 'f4'),
                                               ('C_LYA', 'f4'), ('C_CIV', 'f4'), ('C_CIII', 'f4'), ('C_MgII', 'f4'), ('C_Hbeta', 'f4'), ('C_Halpha', 'f4'),
                                               ('Z_LYA', 'f4'), ('Z_CIV', 'f4'), ('Z_CIII', 'f4'), ('Z_MgII', 'f4'), ('Z_Hbeta', 'f4'), ('Z_Halpha', 'f4')])

    data['TARGETID'] = dataframe['TARGETID']
    data['RA'] = dataframe['RA']
    data['DEC'] = dataframe['DEC']

    data['Z'] = dataframe['Z']
    data['ZERR'] = dataframe['ZERR']
    data['COEFFS'] = np.array([np.array(dataframe['COEFFS'][i]) for i in range(dataframe.shape[0])])
    data['SPECTYPE'] = dataframe['SPECTYPE']
    data['Z_RR'] = dataframe['Z_RR']

    data['Z_QN'] = dataframe['Z_QN']
    data['C_LYA'] = np.array([dataframe['C_LINES'][i][0] for i in range(dataframe.shape[0])])
    data['C_CIV'] = np.array([dataframe['C_LINES'][i][1] for i in range(dataframe.shape[0])])
    data['C_CIII'] = np.array([dataframe['C_LINES'][i][2] for i in range(dataframe.shape[0])])
    data['C_MgII'] = np.array([dataframe['C_LINES'][i][3] for i in range(dataframe.shape[0])])
    data['C_Hbeta'] = np.array([dataframe['C_LINES'][i][4] for i in range(dataframe.shape[0])])
    data['C_Halpha'] = np.array([dataframe['C_LINES'][i][5] for i in range(dataframe.shape[0])])

    data['Z_LYA'] = np.array([dataframe['Z_LINES'][i][0] for i in range(dataframe.shape[0])])
    data['Z_CIV'] = np.array([dataframe['Z_LINES'][i][1] for i in range(dataframe.shape[0])])
    data['Z_CIII'] = np.array([dataframe['Z_LINES'][i][2] for i in range(dataframe.shape[0])])
    data['Z_MgII'] = np.array([dataframe['Z_LINES'][i][3] for i in range(dataframe.shape[0])])
    data['Z_Hbeta'] = np.array([dataframe['Z_LINES'][i][4] for i in range(dataframe.shape[0])])
    data['Z_Halpha'] = np.array([dataframe['Z_LINES'][i][5] for i in range(dataframe.shape[0])])

    fits = fitsio.FITS(filename, 'rw', clobber=clobber)
    fits.write(data, extname='QN+RR')
    if clobber:
        log.info(f'OVERWRITE the file : {filename}')
    else:
        log.info(f'EXPAND the file : {filename}')
    fits.close()

    return


if __name__ == "__main__":
    args = collect_argparser()

    spectra_name = args.coadd
    zbest_name = args.zbest
    target_version = args.target_version
    output_name = args.output


    ## Selection param for QuasarNet
    param_QN = {'c_thresh':args.c_thresh, 'n_thresh':args.n_thresh}

    param_RR = {'template_filename':args.template,
                'filename_priors':args.filename_priors,
                'filename_output_rerun_RR':args.filename_output_rerun_RR,
                'filename_zbest_rerun_RR':args.filename_zbest_rerun_RR,
                'delete_RR_output':args.delete_RR_output}

    if os.path.isfile(spectra_name) & os.path.isfile(zbest_name):
        # open best fit file generated by redrock
        zbest_file = fitsio.FITS(zbest_name)
        zbest = zbest_file[1]
        fibermap = zbest_file[2]
        index_sorted = np.argsort(fibermap['TARGETID'][:500]) # in zbest targetid are sorted, it is not the case in the fibermap

        if target_version == 'SV1':
            DESI_TARGET = 'SV1_DESI_TARGET'
        elif target_version == 'SV3':
            DESI_TARGET = 'SV3_DESI_TARGET'
        elif target_version == 'MAIN':
            DESI_TARGET = 'DESI_TARGET'
        else:
            log.error("**** CHOOSE CORRECT VERSION OF TARGET ****")
            sys.exit()

        is_qso_target = fibermap[DESI_TARGET][:500][index_sorted] & 2**2 != 0

        log.info(f"Nbr objetcs for QN: {is_qso_target.sum()}")
        QSO_from_QN = selection_targets_with_QN(zbest, fibermap, index_sorted, is_qso_target, spectra_name, param_QN, param_RR)
        log.info(f"Selected with QN + new_Z: {QSO_from_QN.shape[0]}")

        # close file !!
        zbest_file.close()

        save_dataframe_to_fits(QSO_from_QN, output_name, DESI_TARGET)

    else: # file for the consider Tile / Night / petal does not exist
        log.error(f"There is problem with files: {spectra_name} or {zbest_name}")
