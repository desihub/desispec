#!/usr/bin/env python


import sys,string
import astropy.io.fits as pyfits
import argparse
import numpy as np
from scipy.stats import iqr
from scipy.ndimage.morphology import binary_closing

from desispec import io
from desiutil.log import get_logger
from desispec.preproc import  _parse_sec_keyword
from desispec.maskbits import ccdmask

#Parser to take arguments from command line
parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
description="Compute a mask using dark images",
 epilog='''Input is a list of raw dark images (Possibly with different exposure times). Raw images are preprocessed with ONLY gain (if available) and bias corrections and calculated per unit time. Median and IQR of the darks are calculated and cuts set in that domain in terms of percentiles to create the masks.''')

parser.add_argument('-i','--image', type = str, default = None, required = True, nargs="*",
                    help = 'paths to raw dark image fits files')
parser.add_argument('-o','--outfile', type = str, default = None, required = True,
                    help = 'output mask filename')
parser.add_argument('--camera',type = str, required = True,
                    help = 'header HDU (int or string)')

parser.add_argument('--bias', type = str, default = None, required=True,
                        help = 'bias image calibration file')

parser.add_argument('--minmed', type = float, default = 0.0001, required = True,
                    help = 'Minimum percentile threshold for good median')
parser.add_argument('--maxmed', type = float, default = 99.999, required = True,
                    help = 'Maximum percentile threshold for good median')
parser.add_argument('--miniqr', type = float, default = 0, required = True,
                    help = 'Minimum percentile threshold for good IQR')
parser.add_argument('--maxiqr', type = float, default = 99.999, required = True,
                    help = 'Maximum percentile threshold for good IQR')
parser.add_argument('--mask', type = str, default = None, required = False,
                    help = 'Path to a previous mask file. If given, the output is the bitwise OR of the input mask and the mask created by this script.')
parser.add_argument('--savestat', type = bool, default = False, required = False,
                    help = 'Whether to save the intermediate dark frame statistics')
parser.add_argument('--outfilestat', type = str, default = None, required = False,
                    help = 'output image filename for statistics file')

args = parser.parse_args()
log  = get_logger()

log.info("read images ...")

shape=None
images=[]

#Read all the dark images
for filename in args.image :

    log.info(filename)

    # collect exposure times
    fitsfile=pyfits.open(filename)
    primary_header = fitsfile[0].header
    if not "EXPTIME" in primary_header :
        primary_header = fitsfile[1].header
    exptime = primary_header["EXPTIME"]
    fitsfile.close()

    # read raw data and preprocess them
    img = io.read_raw(filename, args.camera,
                      bias=args.bias,
                      nogain=False,
                      nocosmic=True,
                      mask=False,
                      dark=False,
                      pixflat=False,
                      nocrosstalk=True,
                      ccd_calibration_filename=False)

    shape=img.pix.shape
    log.info("adding dark %s divided by exposure time %f s"%(filename,exptime))
    images.append(img.pix/exptime)
    
images=np.array(images)


log.info("compute median image ...")
med_image = np.median(images, axis=0)
log.info("computed median image ...")

log.info("compute IQR image ...")
iqr_image = iqr(images, axis=0)

if args.savestat:
    log.info("writing output to %s ..."%args.outfile)
    hdulist=pyfits.HDUList([pyfits.PrimaryHDU(), pyfits.ImageHDU(med_image, name="MEDIAN"), pyfits.ImageHDU(iqr_image, name="IQR")])

    #Write header info
    for i, filename in enumerate(args.image) :
        hdulist[0].header["INPUT%03d"%i]=filename
    hdulist[0].header["CAMERA"]=args.camera
    hdulist[0].header["NUMEXP"]=len(args.image)

    hdulist.writeto(args.outfilestat, overwrite=True)
    log.info("Done writing statistics file")
    

#Create the masks
mask   = np.zeros(shape, dtype=np.int32)
minmed = np.percentile(med_image,args.minmed)
maxmed = np.percentile(med_image,args.maxmed)
miniqr = np.percentile(iqr_image,args.miniqr)
maxiqr = np.percentile(iqr_image,args.maxiqr)

log.info("writing mask bits")
#Set the Bad flag absed on thresholds
mask[(med_image>maxmed)|(med_image<minmed)|(iqr_image>maxiqr)|(iqr_image<miniqr)] |= ccdmask.BAD
#Close incompletely blocked regions
closed_mask = binary_closing(mask, iterations=3, structure=np.ones([2,2]).astype(np.int32))
mask |= closed_mask.astype(np.int32)

#Set hot pixel flag
mask[(med_image>maxmed)] |= ccdmask.HOT
#Set Dead pixel Flag
mask[(med_image<minmed)|(iqr_image<miniqr)] |= ccdmask.DEAD
#Set high variability flag (change the name in mask bits)
mask[(iqr_image>maxiqr)] |= ccdmask.HIGHVAR

#Incorporate a previously created mask using a bitwise OR
if args.mask!=None:
    mask_old = pyfits.open(args.mask)[0].data
    mask = (mask | mask_old)
    log.info("Taken bitwise OR of input mask and the generated mask")
#Write fits file with header info

hdu = pyfits.PrimaryHDU(mask)
hdu.header["MINMED"] = (args.minmed, 'Minimum percentile threshold for good median')
hdu.header["MAXMED"] = (args.maxmed, 'Maximum percentile threshold for good median')
hdu.header["MINIQR"] = (args.miniqr, 'Minimum percentile threshold for good IQR')
hdu.header["MAXIQR"] = (args.maxiqr, 'Maximum percentile threshold for good IQR')
hdu.header["CAMERA"] = (args.camera, 'header HDU (int or string)')
hdu.header["OLDMASK"] = (args.mask, 'Path to a previous mask file taken as OR.')
hdu.header["BIAS"] = (args.bias, 'Path to bias image calibration file')
hdu.header["DARKS"] = (" ".join(args.image), 'paths to raw dark image fits files')


hdu.writeto(args.outfile, overwrite=True)
log.info("Saved masks file")