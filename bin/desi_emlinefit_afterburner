#!/usr/bin/env python

import os
import sys
from time import time
import fitsio
from astropy.time import Time
import numpy as np
from desiutil.log import get_logger
from argparse import ArgumentParser
from desispec.io.emlinefit import (
    allowed_emnames,
    get_rf_em_waves,
    get_emlines,
)

def get_parse(log=get_logger()):
    # AR some defaults
    default_emnames = "OII,HDELTA,HGAMMA,HBETA,OIII,HALPHA"
    default_rr_keys = "TARGETID,Z,ZWARN,SPECTYPE,DELTACHI2"
    default_fm_keys = "TARGET_RA,TARGET_DEC,OBJTYPE"
    #
    parser = ArgumentParser()
    parser.add_argument(
        "--redrockfn",
        help="full path to a redrock/zbest file (default=None)",
        type=str,
        default=None,
        required=True,
    )
    parser.add_argument(
        "--coaddfn",
        help="full path to a coadd file (everest-formatted) (default=None)",
        type=str,
        default=None,
        required=True,
    )
    parser.add_argument(
        "--outfn",
        help="full path to output fits file (default=None)",
        type=str,
        default=None,
        required=True,
    )
    parser.add_argument(
        "--emnames",
        help="comma-separated list of emission lines to fit; allowed: {} (default={})".format(",".join(allowed_emnames), default_emnames),
        type=str,
        default=",".join(allowed_emnames),
    )
    parser.add_argument(
        "--rf_fit_hw",
        help="*rest-frame* wavelength width (in A) used for fitting on each side of the line (default=40)",
        type=float,
        default=40,
    )
    parser.add_argument(
        "--min_rf_fit_hw",
        help="minimum requested *rest-frame* width (in A) on each side of the line to consider the fitting (default=20)",
        type=float,
        default=20,
    )
    parser.add_argument(
        "--rf_cont_w",
        help="*rest-frame* wavelength extent (in A) to fit the continuum (default=200)",
        type=float,
        default=200,
    )
    parser.add_argument(
        "--rv",
        help="value of R_V to convert EBV to magnitudes (default=3.1)",
        type=float,
        default=3.1,
    )
    parser.add_argument(
        "--balmerfit",
        help="how to fit Balmer lines? 'em': emission line only; 'em+abs': emission+absorption lines (default=em)",
        type=str,
        default="em",
    )
    parser.add_argument(
        "--outpdf",
        help="PDF filename for plotting the fitted lines (data + fit) (default=None)",
        type=str,
        default=None,
        required=False
    )
    parser.add_argument(
        "--rr_keys",
        help="comma-separated list of columns from the REDSHIFTS extension to propagate (default={})".format(default_rr_keys),
        type=str,
        default=default_rr_keys,
        required=False,
    )
    parser.add_argument(
        "--fm_keys",
        help="comma-separated list of columns from the FIBERMAP extension to propagate (default={})".format(default_fm_keys),
        type=str,
        default=default_fm_keys,
        required=False,
    )
    args = parser.parse_args()
    # AR sanity check
    for emname in args.emnames.split(","):
        if emname not in allowed_emnames:
            log.error("{} not in allowed args.emnames ({}); exiting".format(emname, ",".join(allowed_emnames)))
            sys.exit(1)
    #
    for kwargs in args._get_kwargs():
        log.info(kwargs)
    return args


def main():
    start = time()
    log = get_logger()
    log.info("{:.1f}s\tstart\tTIMESTAMP={}".format(time() - start, Time.now().isot))
    # AR read arguments
    args = get_parse(log=log)
    # AR fit the emission lines
    emdict, rr_dtype, fm_dtype = get_emlines(
        args.redrockfn,
        args.coaddfn,
        emnames=args.emnames.split(","),
        rf_fit_hw=args.rf_fit_hw,
        min_rf_fit_hw=args.min_rf_fit_hw,
        rf_cont_w=args.rf_cont_w,
        rv=args.rv,
        balmerfit=args.balmerfit,
        outpdf=args.outpdf,
        rr_keys=args.rr_keys,
        fm_keys=args.fm_keys,
        log=log,
        )
    # AR data model
    dtype = rr_dtype + fm_dtype
    for emname in args.emnames.split(","):
        for key in list(emdict[emname].keys()):
            if key not in ["wave", "fitdata", "fitivar", "model"]:
                if key == "NDOF":
                    dtype.append(("{}_{}".format(emname, key), ">i4"))
                else:
                    dtype.append(("{}_{}".format(emname, key), ">f4"))
    # AR store in table
    d = np.zeros(len(emdict["TARGETID"]), dtype=dtype)
    # AR not using args.rr_keys, args_fm_keys, as keys not present
    # AR in args.redrockfn would not be propagated
    for key in [x[0] for x in rr_dtype] + [x[0] for x in fm_dtype]:
        d[key] = emdict[key]
    for emname in args.emnames.split(","):
        for key in list(emdict[emname].keys()):
            if key not in ["wave", "fitdata", "fitivar", "model"]:
                d["{}_{}".format(emname, key)] = emdict[emname][key]
    # AR write to fits
    if os.path.isfile(args.outfn):
        log.info("Removing existing {}".format(args.outfn))
        os.remove(args.outfn)
    fd = fitsio.FITS(args.outfn, "rw")
    fd.write(d, extname="EMLINEFIT")
    fd.close()
    # AR adding infos in the EMLINEFIT header
    # AR - (some of the) arguments
    # AR - rest-frame wavelengths
    fd = fitsio.FITS(args.outfn, "rw")
    fd["EMLINEFIT"].write_key("RRFN", args.redrockfn)
    fd["EMLINEFIT"].write_key("COADDFN", args.coaddfn)
    fd["EMLINEFIT"].write_key("RFHW", args.rf_fit_hw)
    fd["EMLINEFIT"].write_key("MINRFHW", args.min_rf_fit_hw)
    fd["EMLINEFIT"].write_key("RFCONTW", args.rf_cont_w)
    fd["EMLINEFIT"].write_key("RV", args.rv)
    fd["EMLINEFIT"].write_key("BALMFIT", args.balmerfit)
    fd["EMLINEFIT"].write_key("EMNAMES", args.emnames)
    for i_emname, emname in enumerate(args.emnames.split(",")):
        fd["EMLINEFIT"].write_key("RFWAVE{:02d}".format(i_emname), ",".join(get_rf_em_waves(emname).astype(str)))
    fd.close()
    #
    log.info("{:.1f}s\tdone\tTIMESTAMP={}".format(time() - start, Time.now().isot))


if __name__ == "__main__":
    main()
