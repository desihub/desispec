#!/usr/bin/env python

"""
One stop shopping for processing a DESI exposure

Examples at NERSC:

# ARC: 18 min on 2 nodes
time srun -N 2 -n 60 -C haswell -t 25:00 --qos realtime desi_proc --mpi -n 20191029 -e 22486

# FLAT: 13 min
time srun -n 20 -N 1 -C haswell -t 15:00 --qos realtime desi_proc --mpi -n 20191029 -e 22487

# TWILIGHT: 8min
time srun -n 20 -N 1 -C haswell -t 15:00 --qos realtime desi_proc --mpi -n 20191029 -e 22497

# SKY: 11 min
time srun -n 20 -N 1 -C haswell -t 15:00 --qos realtime desi_proc --mpi -n 20191029 -e 22536

# ZERO: 2 min
time srun -n 20 -N 1 -C haswell -t 15:00 --qos realtime desi_proc --mpi -n 20191029 -e 22561
"""

import time
from collections import OrderedDict

progress = OrderedDict(start=time.asctime())

import sys, os, argparse, re, time, collections
import subprocess
from copy import deepcopy

import numpy as np
import fitsio
from astropy.io import fits
import glob
import desispec.io
from desispec.io import findfile
from desispec.io.util import create_camword, find_most_recent
from desispec.calibfinder import findcalibfile,CalibFinder
from desispec.fiberflat import apply_fiberflat
from desispec.sky import subtract_sky
from desispec.util import runcmd
import desispec.scripts.extract
import desispec.scripts.specex

from desitarget.targetmask import desi_mask

from desiutil.log import get_logger, DEBUG, INFO

def get_desi_proc_parser():
    """
    Create an argparser object to use to generate arguments from input data.
    """
    parser = argparse.ArgumentParser(usage = "{prog} [options]")
    parser.add_argument("-n", "--night", type=int,  help="YEARMMDD night")
    parser.add_argument("-e", "--expid", type=int,  help="Exposure ID")
    parser.add_argument("--obstype", type=str,  help="science, arc, flat, dark, zero, ...")
    parser.add_argument("--cameras", type=str,  help="Explicitly define the spectrographs for which you want"+
                                                     " to reduce the data. Should be a comma separated list."+
                                                     " Numbers only assumes you want to reduce R, B, and Z "+
                                                     "for that spectrograph. Otherwise specify separately [BRZ|brz][0-9].")
    parser.add_argument("-i", "--input", type=str,  help="input raw data file")
    parser.add_argument("--mpi", action="store_true", help="Use MPI parallelism")
    parser.add_argument("--fframe", action="store_true", help="Also write non-sky subtracted fframe file")
    parser.add_argument("--traceshift", action="store_true", help="Do shift traces")
    parser.add_argument("--noprestdstarfit", action="store_true", help="Do not do any science reductions prior to stdstar fitting")
    parser.add_argument("--nofiberflat", action="store_true", help="Do not apply fiberflat")
    parser.add_argument("--noskysub", action="store_true", help="Do not subtract the sky. Also skips stdstar fit and flux calib")
    parser.add_argument("--noprestdstarfit", action="store_true", help="Do not do any science reductions prior to stdstar fitting")
    parser.add_argument("--nostdstarfit", action="store_true", help="Do not fit standard stars")
    parser.add_argument("--nofluxcalib", action="store_true", help="Do not flux calibrate")
    parser.add_argument('--maxstdstars', type=int, default=None, \
                        help='Maximum number of stdstars to include')
    parser.add_argument("--psf",type=str,required=False,default=None, help="use this input psf (trace shifts will still be computed)")
    parser.add_argument("--fiberflat",type=str,required=False,default=None, help="use this fiberflat")
    parser.add_argument("--calibnight",type=int,required=False,default=None, help="use this night to find nightly PSF and fiberflats")
    parser.add_argument("--scattered-light",action='store_true',help="fit and remove scattered light")
    parser.add_argument("--extra-variance", action='store_true',
                        help = 'increase sky model variance based on chi2 on sky lines')
    parser.add_argument("--batch", action="store_true", help="Submit a batch job to process this exposure")
    parser.add_argument("--nosubmit", action="store_true", help="Create batch script but don't submit")
    parser.add_argument("-q", "--queue", type=str, default="realtime", help="batch queue to use")
    parser.add_argument("--batch-opts", type=str, default=None, help="additional batch commands")
    parser.add_argument("--runtime", type=int, default=None,  help="batch runtime in minutes")
    parser.add_argument("--most-recent-calib",action="store_true",help="If no calibrations exist for the night,"+\
                        " use the most recent calibrations from *past* nights. If not set, uses default calibs instead.")
    return parser


def update_args_with_headers(args):
    """
    Update input argparse object with values from header if the argparse values are uninformative defaults (generally 
    python None). This also returns the primary header and each camera's header.

    Args:
        args: argparse arguments object. Parsed from the command line arguments based on the parser defined 
                  by the function get_desi_proc_parser().
    
    Returns:
        args: modified version of the input args where values have been updated if None using information from 
                  appropriate headers using either night+expid or an input file.
        hdr: fitsio header object obtained using *.read_header() on input file or file determined from args information.
        camhdr: dict, dictionary of fitsio header objects for each camera in the input files.

    Note:
        The input args is modified and returned here.
    """
    if args.input is None:
        if args.night is None or args.expid is None:
            raise RuntimeError('Must specify --input or --night AND --expid')

        args.input = findfile('raw', night=args.night, expid=args.expid)

    if not os.path.isfile(args.input):
        raise IOError('Missing input file: {}'.format(args.input))

    #- Fill in values from raw data header if not overridden by command line                             
    fx = fitsio.FITS(args.input)
    if 'SPEC' in fx:                                #- 20200225 onwards                                 
        #hdr = fits.getheader(args.input, 'SPEC')                                                   
        hdr = fx['SPEC'].read_header()
    elif 'SPS' in fx:                               #- 20200224 and before                                     
        #hdr = fits.getheader(args.input, 'SPS')                                                       
        hdr = fx['SPS'].read_header()
    else:
        #hdr = fits.getheader(args.input, 0)                                                                   
        hdr = fx[0].read_header()

    if args.expid is None:
        args.expid = int(hdr['EXPID'])

    if args.night is None:
        args.night = int(hdr['NIGHT'])

    if args.obstype is None:
        if 'OBSTYPE' in hdr:
            args.obstype = hdr['OBSTYPE'].strip()
        elif 'FLAVOR' in hdr:
            args.obstype = hdr['FLAVOR'].strip()
            log.warning('Using OBSTYPE={} from FLAVOR keyword'.format(args.obstype))
        else:
            raise RuntimeError('Need --obstype or OBSTYPE or FLAVOR header keywords')

    if args.cameras is None:
        recam = re.compile('^[brzBRZ][\d]$')
        cameras = list()
        for hdu in fx.hdu_list:
            if recam.match(hdu.get_extname()):
                cameras.append(hdu.get_extname().lower())

        if len(cameras) == 0:
            raise RuntimeError("No [BRZ][0-9] camera HDUs found in {}".format(args.input))

        args.cameras = cameras
        cameras = None
    else:
        cam_str = args.cameras.strip(' \t').lower()
        cameras = cam_str.split(',')
        if cam_str[0] not in ['b','r','z'] and cameras[0].isnumeric():
            args.cameras = []
            for camnum in cameras:
                for ccd in ['b','r','z']:
                    args.cameras.append('{}{}'.format(ccd,camnum))
        else:
            args.cameras = cameras
            
    camhdr = dict()
    for cam in args.cameras:
        camhdr[cam] = fx[cam].read_header()

    fx.close()
    return args, hdr, camhdr


def determine_resources(ncameras,obstype,queue,forced_runtime=None):
    """
    Determine the resources that should be assigned to the batch script given what
    desi_proc needs for the given input information.

    Args:
        ncameras: int, number of cameras to be processed
        obstype: str, type of data being processed
        queue: str, the queue at NERSC to be submitted to. 'realtime' will force 
                    restrictions on number of nodes.
        force_runtime: int, the amount of runtime to allow for the script. Should be left
                            to default heuristics unless needed for some reason.

    Returns:
        ncores: int, number of cores (actually 2xphysical cores) that should be submitted via "-n {ncores}"
        nodes:  int, number of nodes to be requested in the script. Typically  (ncores-1) // 32 + 1
        runtime: int, the max time requested for the script  in seconds for the processing.
    """    
    nspectro = (ncameras-1)//3 + 1
    if obstype in ('ARC', 'TESTARC'):
        ncores, runtime = 20*ncameras, 35
    elif obstype in ('FLAT', 'TESTFLAT'):
        ncores, runtime = 20*nspectro, 15
    elif obstype in ('SKY', 'TWILIGHT', 'SCIENCE'):
        ncores, runtime = 20*nspectro, 30
    elif obstype in ('ZERO', 'DARK'):
        ncores, runtime = ncameras, 5
    else:
        print('ERROR: unknown obstype={}'.format(obstype))
        sys.exit(1)

    if forced_runtime is not None:
        runtime = forced_runtime

    nodes = (ncores-1) // 32 + 1

    #- Arcs and flats make good use of full nodes, but throttle science                                   
    #- exposures to 5 nodes to enable two to run together in the 10-node                                          
    #- realtime queue, since their wallclock is dominated by less                                             
    #- efficient sky and fluxcalib steps                                                                        
    if obstype in ('ARC', 'TESTARC', 'FLAT', 'TESTFLAT'):
        max_realtime_nodes = 10
    else:
        max_realtime_nodes = 5

    if (queue == 'realtime') and (nodes > max_realtime_nodes):
        nodes = max_realtime_nodes
        ncores = 32*nodes
        
    return ncores, nodes, runtime


def create_desi_proc_batch_script(args,batchdir=None,jobname=None):
    """
    Generate a SLURM batch script to be submitted to the slurm scheduler to run desi_proc.

    Args:
        args: argparser object with arguments defined by get_desi_proc_parser or an empty class with the 
              same named properties defined.
        batchdir: can define an alternative location to write the file. The default is to SPECPROD under run/scripts/night/NIGHT
        jobname: name to save this batch script file as and the name of the eventual log file. Script is save  within 
                 the batchdir directory.

    Returns:
        scriptfile: the full path name for the script written.

    Note:                                                                                                         
        batchdir and jobname can be used to define an alternative pathname, but may not work with assumptions in desi_proc.    
            These optional arguments should be used with caution and primarily for debugging. 
    """
    
    if batchdir is None:
       reduxdir = desispec.io.specprod_root()
       batchdir = os.path.join(reduxdir, 'run', 'scripts', 'night', str(args.night))
    os.makedirs(batchdir, exist_ok=True)
    if jobname is None:
        camword = create_camword(args.cameras)
        jobname = '{}-{}-{:08d}-{}'.format(args.obstype.lower(), args.night, args.expid, camword)
    scriptfile = os.path.join(batchdir, jobname+'.slurm')

    ncameras = len(args.cameras)
    ncores, nodes, runtime = determine_resources(ncameras,args.obstype,args.queue,args.runtime)

    assert runtime <= 60

    with open(scriptfile, 'w') as fx:
        fx.write('#!/bin/bash -l\n\n')
        fx.write('#SBATCH -C haswell\n')
        fx.write('#SBATCH -N {}\n'.format(nodes))
        fx.write('#SBATCH -n {}\n'.format(ncores))
        fx.write('#SBATCH --qos {}\n'.format(args.queue))
        if args.batch_opts is not None:
            fx.write('#SBATCH {}\n'.format(args.batch_opts))
        fx.write('#SBATCH --account desi\n')
        fx.write('#SBATCH --job-name {}\n'.format(jobname))
        fx.write('#SBATCH --output {}/{}-%j.log\n'.format(batchdir, jobname))
        fx.write('#SBATCH --time=00:{:02d}:00\n'.format(runtime))

        #- If we are asking for more than half the node, ask for all of it                            
        #- to avoid memory problems with other people's jobs                                                     
        if ncores > 16:
            fx.write('#SBATCH --exclusive\n')

        fx.write('\n')

        inparams = list(sys.argv).copy()
        for parameter in ['-q','--queue','--batch-opts']:
            if parameter in inparams:
                loc = np.where(np.array(inparams)==parameter)[0][0]
                # Remove the command                                                                     
                inparams.pop(loc)
                # Remove the argument of the command (now in the command location after pop)      
                inparams.pop(loc)

        cmd = ' '.join(inparams)
        cmd = cmd.replace(' --batch', ' ').replace(' --nosubmit', ' ')

        if not args.mpi:
            cmd += ' --mpi'

        fx.write(f'# {args.obstype} exposure with {ncameras} cameras\n')
        fx.write(f'# using {ncores} cores on {nodes} nodes\n\n')

        fx.write('echo Starting at $(date)\n')

	fx.write('\n# Do steps through skysub at full MPI parallelism\n')
        srun = 'srun -N {} -n {} -c 2 {} --nofluxcalib'.format(
                nodes, ncores, cmd)
        fx.write('echo Running {}\n'.format(srun))
        fx.write('{}\n'.format(srun))

	if args.obstype == 'SCIENCE':
            fx.write('\n# Then switch to less MPI parallelism for fluxcalib MP parallelism\n')
            fx.write('# This should quickly skip over the steps already done\n')
            srun = 'srun -N {} -n {} -c 32 {} '.format(nodes, nodes*2, cmd)
            fx.write('if [ $? -eq 0 ]; then\n')
            fx.write('  echo Running {}\n'.format(srun))
            fx.write('  {}\n'.format(srun))
            fx.write('else\n')
            fx.write('  echo FAILED: done at $(date)\n')
            fx.write('  exit 1\n')
            fx.write('fi\n')

        fx.write('\nif [ $? -eq 0 ]; then\n')
        fx.write('  echo SUCCESS: done at $(date)\n')
        fx.write('else\n')
        fx.write('  echo FAILED: done at $(date)\n')
        fx.write('  exit 1\n')
        fx.write('fi\n')

    print('Wrote {}'.format(scriptfile))
    print('logfile will be {}/{}-JOBID.log\n'.format(batchdir, jobname))

    return scriptfile







    

parser = get_desi_proc_parser()
args = parser.parse_args()
log = get_logger()

#- Freeze IERS after parsing args so that it doesn't bother if only --help
import desiutil.iers
desiutil.iers.freeze_iers()


if args.mpi and not args.batch:
    from mpi4py import MPI
    comm = MPI.COMM_WORLD
    rank = comm.rank
    size = comm.size
else:
    comm = None
    rank = 0
    size = 1

#- Prevent MPI from killing off spawned processes
if 'PMI_MMAP_SYNC_WAIT_TIME' not in os.environ:
    os.environ['PMI_MMAP_SYNC_WAIT_TIME'] = '3600'

#- Preflight checks
if rank > 0:
    #- Let rank 0 fetch these, and then broadcast
    args, hdr, camhdr = None, None, None
else:
    args, hdr, camhdr = update_args_with_headers(args)
    #- Update args to be in consistent format
    if args.batch_opts is not None:
        args.batch_opts = args.batch_opts.strip('"\'')
    args.cameras = sorted(args.cameras)
    args.obstype = args.obstype.upper()
    
if comm is not None:
    args = comm.bcast(args, root=0)
    hdr = comm.bcast(hdr, root=0)
    camhdr = comm.bcast(camhdr, root=0)

known_obstype = ['SCIENCE', 'ARC', 'FLAT', 'ZERO', 'DARK',
    'TESTARC', 'TESTFLAT', 'PIXFLAT', 'SKY', 'TWILIGHT', 'OTHER']
if args.obstype not in known_obstype:
    raise RuntimeError('obstype {} not in {}'.format(args.obstype, known_obstype))

#-------------------------------------------------------------------------
#- Create and submit a batch job if requested

if args.batch:
    scriptfile = create_desi_proc_batch_script(args)
    err = 0
    if not args.nosubmit:
        err = subprocess.call(['sbatch', scriptfile])
    sys.exit(err)

#-------------------------------------------------------------------------
#- Proceeding with running

#- What are we going to do?
if rank == 0:
    log.info('----------')
    log.info('Input {}'.format(args.input))
    log.info('Night {} expid {}'.format(args.night, args.expid))
    log.info('Obstype {}'.format(args.obstype))
    log.info('Cameras {}'.format(args.cameras))
    log.info('Output root {}'.format(desispec.io.specprod_root()))
    log.info('----------')

#- Create output directories if needed
if rank == 0:
    preprocdir = os.path.dirname(findfile('preproc', args.night, args.expid, 'b0'))
    expdir = os.path.dirname(findfile('frame', args.night, args.expid, 'b0'))
    os.makedirs(preprocdir, exist_ok=True)
    os.makedirs(expdir, exist_ok=True)

#- Wait for rank 0 to make directories before proceeding
if comm is not None:
    comm.barrier()

if rank == 0:
    progress['init'] = time.asctime()

#-------------------------------------------------------------------------
#- Preproc
#- All obstypes get preprocessed (unless noprestdstarfit)

if rank == 0:
    log.info('Starting preproc at {}'.format(time.asctime()))

#- Assemble fibermap for science exposures
fibermap = None
fibermap_ok = None
if rank == 0 and args.obstype == 'SCIENCE':
    fibermap = findfile('fibermap', args.night, args.expid)
    if not os.path.exists(fibermap):
        tmp = findfile('preproc', args.night, args.expid, 'b0')
        preprocdir = os.path.dirname(tmp)
        fibermap = os.path.join(preprocdir, os.path.basename(fibermap))

        log.info('Creating fibermap {}'.format(fibermap))
        cmd = 'assemble_fibermap -n {} -e {} -o {}'.format(
                args.night, args.expid, fibermap)
        runcmd(cmd, inputs=[], outputs=[fibermap])

    fibermap_ok = os.path.exists(fibermap)

    #- Some commissioning files didn't have coords* files that caused assemble_fibermap to fail
    #- these are well known failures with no other solution, so for those, just force creation
    #- of a fibermap with null coordinate information
    if not fibermap_ok and int(args.night) <	20200310:
        log.info("Since night is before 20200310, trying to force fibermap creation without coords file")
        cmd += ' --force'
        runcmd(cmd, inputs=[], outputs=[fibermap])
        fibermap_ok = os.path.exists(fibermap)   
    
#- If assemble_fibermap failed and obstype is SCIENCE, exit now
if comm is not None:
    fibermap_ok = comm.bcast(fibermap_ok, root=0)

if args.obstype == 'SCIENCE' and not fibermap_ok:
    sys.stdout.flush()
    if rank == 0:
        log.critical('assemble_fibermap failed for science exposure; exiting now')

    sys.exit(13)

#- Wait for rank 0 to make fibermap if needed
if comm is not None:
    fibermap = comm.bcast(fibermap, root=0)

if not (args.obstype in ['SCIENCE',] and args.noprestdstarfit):
    for i in range(rank, len(args.cameras), size):
        camera = args.cameras[i]
        outfile = findfile('preproc', args.night, args.expid, camera)
        outdir = os.path.dirname(outfile)
        cmd = "desi_preproc -i {} -o {} --outdir {} --cameras {}".format(
            args.input, outfile, outdir, camera)
        if args.scattered_light :
            cmd += " --scattered-light"
        if fibermap is not None:
            cmd += " --fibermap {}".format(fibermap)

        runcmd(cmd, inputs=[args.input], outputs=[outfile])

    if comm is not None:
        comm.barrier()

    if rank == 0:
        progress['preproc'] = time.asctime()

#-------------------------------------------------------------------------
#- Get input PSFs
input_psf = dict()
if rank == 0:
    for camera in args.cameras :
        if args.psf is not None :
            input_psf[camera] = args.psf
        elif args.calibnight is not None :
            # look for a psfnight psf for this calib night
            psfnightfile = findfile('psfnight', args.calibnight, args.expid, camera)
            if not os.path.isfile(psfnightfile) :
                log.error("no {}".format(psfnightfile))
                raise IOError("no {}".format(psfnightfile))
            input_psf[camera] = psfnightfile
        else :
            # look for a psfnight psf 
            psfnightfile = findfile('psfnight', args.night, args.expid, camera)
            if os.path.isfile(psfnightfile) :
                input_psf[camera] = psfnightfile
            elif args.most_recent_calib:
                nightfile = find_most_recent(args.night, file_type='psfnight')
                if nightfile is None:
                    input_psf[camera] = findcalibfile([hdr, camhdr[camera]], 'PSF')
                else:
                    input_psf[camera] = nightfile
            else :
                input_psf[camera] = findcalibfile([hdr, camhdr[camera]], 'PSF')
        log.info("Will use input PSF : {}".format(input_psf[camera]))

if comm is not None:
    input_psf = comm.bcast(input_psf, root=0)

#-------------------------------------------------------------------------
#- Traceshift

if ( args.obstype in ['FLAT', 'TESTFLAT', 'SKY', 'TWILIGHT']     )   or
   ( args.obstype in ['SCIENCE',] and (not args.noprestdstarfit) ):
    if rank == 0 and args.traceshift :
        log.info('Starting traceshift at {}'.format(time.asctime()))

    for i in range(rank, len(args.cameras), size):
        camera = args.cameras[i]
        preprocfile = findfile('preproc', args.night, args.expid, camera)
        inpsf  = input_psf[camera]
        outpsf = findfile('psf', args.night, args.expid, camera)
        if not os.path.isfile(outpsf) :
            if args.traceshift :
                cmd = "desi_compute_trace_shifts"
                cmd += " -i {}".format(preprocfile)
                cmd += " --psf {}".format(inpsf)
                cmd += " --outpsf {}".format(outpsf)
                cmd += " --degxx 2 --degxy 0"
                if args.obstype in ['FLAT', 'TESTFLAT', 'TWILIGHT'] :
                    cmd += " --continuum"
                else :
                    cmd += " --degyx 2 --degyy 0"
                if args.obstype in ['SCIENCE', 'SKY']:
                    cmd += ' --sky'
                elif args.obstype in ['ARC', 'TESTARC']:
                    cmd += ' --arc-lamps'
            else :
                cmd = "ln -s {} {}".format(inpsf,outpsf)  
            runcmd(cmd, inputs=[preprocfile, inpsf], outputs=[outpsf])
        else :
            log.info("PSF {} exists".format(outpsf))

    if comm is not None:
        comm.barrier()

    if rank == 0:
        progress['traceshift'] = time.asctime()

#-------------------------------------------------------------------------
#- PSF
#- MPI parallelize this step

if args.obstype in ['ARC', 'TESTARC']:
    
    if rank == 0:
        log.info('Starting traceshift before specex PSF fit at {}'.format(time.asctime()))

    for i in range(rank, len(args.cameras), size):
        camera = args.cameras[i]
        preprocfile = findfile('preproc', args.night, args.expid, camera)
        inpsf  = input_psf[camera]
        outpsf = findfile('psf', args.night, args.expid, camera).replace("psf","shifted-input-psf")
        if not os.path.isfile(outpsf) :
            cmd = "desi_compute_trace_shifts"
            cmd += " -i {}".format(preprocfile)
            cmd += " --psf {}".format(inpsf)
            cmd += " --outpsf {}".format(outpsf)
            cmd += " --degxx 0 --degxy 0 --degyx 0 --degyy 0"
            cmd += ' --arc-lamps'
            runcmd(cmd, inputs=[preprocfile, inpsf], outputs=[outpsf])
        else :
             log.info("PSF {} exists".format(outpsf))

    if comm is not None:
        comm.barrier()
        
    if rank == 0:
        log.info('Starting specex PSF fitting at {}'.format(time.asctime()))
    
    if rank > 0:
        cmds = inputs = outputs = None
    else:
        cmds = dict()
        inputs = dict()
        outputs = dict()
        for camera in args.cameras:
            preprocfile = findfile('preproc', args.night, args.expid, camera)
            tmpname = findfile('psf', args.night, args.expid, camera)
            inpsf = tmpname.replace("psf","shifted-input-psf")
            outpsf = tmpname.replace("psf","fit-psf")
            
            log.info("now run specex psf fit")
            
            cmd = 'desi_compute_psf'
            cmd += ' --input-image {}'.format(preprocfile)
            cmd += ' --input-psf {}'.format(inpsf)
            cmd += ' --output-psf {}'.format(outpsf)
            
            # look for fiber blacklist
            cfinder = CalibFinder([hdr, camhdr[camera]])
            blacklistkey="FIBERBLACKLIST"
            if not cfinder.haskey(blacklistkey) and cfinder.haskey("BROKENFIBERS") :
                log.warning("BROKENFIBERS yaml keyword deprecated, please use FIBERBLACKLIST")
                blacklistkey="BROKENFIBERS"

            if cfinder.haskey(blacklistkey) :
                blacklist = cfinder.value(blacklistkey)
                cmd += ' --broken-fibers {}'.format(blacklist)
                if rank == 0 :
                    log.warning('broken fibers: {}'.format(blacklist))

            if not os.path.exists(outpsf):
                cmds[camera] = cmd
                inputs[camera] = [preprocfile, inpsf]
                outputs[camera] = [outpsf,]
        
    if comm is not None:
        cmds = comm.bcast(cmds, root=0)
        inputs = comm.bcast(inputs, root=0)
        outputs = comm.bcast(outputs, root=0)
        #- split communicator by 20 (number of bundles)
        group_size = 20
        if (rank == 0) and (size%group_size != 0):
            log.warning('MPI size={} should be evenly divisible by {}'.format(
                size, group_size))
    
        group = rank // group_size
        num_groups = (size + group_size - 1) // group_size
        comm_group = comm.Split(color=group)
        
        for i in range(group, len(args.cameras), num_groups):
            camera = args.cameras[i]
            if camera in cmds:
                cmdargs = cmds[camera].split()[1:]
                cmdargs = desispec.scripts.specex.parse(cmdargs)
                if comm_group.rank == 0:
                    print('RUNNING: {}'.format(cmds[camera]))

                desispec.scripts.specex.main(cmdargs, comm=comm_group)

        comm.barrier()
        
    else:
        log.warning('fitting PSFs without MPI parallelism; this will be SLOW')
        for camera in args.cameras:
            if camera in cmds:
                runcmd(cmds[camera], inputs=inputs[camera], outputs=outputs[camera])

    if comm is not None:
        comm.barrier()

    if rank == 0:
        # loop on all cameras and interpolate bad fibers
        for camera in args.cameras:
            
            # look for fiber blacklist
            cfinder = CalibFinder([hdr, camhdr[camera]])
            blacklistkey="FIBERBLACKLIST"
            if not cfinder.haskey(blacklistkey) and cfinder.haskey("BROKENFIBERS") :
                log.warning("BROKENFIBERS yaml keyword deprecated, please use FIBERBLACKLIST")
                blacklistkey="BROKENFIBERS"
            
            if cfinder.haskey(blacklistkey):
                fiberblacklist = cfinder.value(blacklistkey)
                tmpname = findfile('psf', args.night, args.expid, camera)
                inpsf = tmpname.replace("psf","fit-psf")
                outpsf = tmpname.replace("psf","fit-psf-fixed-blacklisted")
                if os.path.isfile(inpsf) and not os.path.isfile(outpsf):
                    cmd = 'desi_interpolate_fiber_psf'
                    cmd += ' --infile {}'.format(inpsf)
                    cmd += ' --outfile {}'.format(outpsf)
                    cmd += ' --fibers {}'.format(fiberblacklist)
                    log.info('For camera {} interpolating PSF for broken fibers: {}'.format(camera,fiberblacklist))
                    runcmd(cmd, inputs=[inpsf], outputs=[outpsf])
                    if os.path.isfile(outpsf) :
                        os.rename(inpsf,inpsf.replace("fit-psf","fit-psf-before-blacklisted-fix"))
                        subprocess.call('cp {} {}'.format(outpsf,inpsf),shell=True)

    if rank == 0:
        progress['psf'] = time.asctime()

        
#-------------------------------------------------------------------------
#- Extract
#- This is MPI parallel so handle a bit differently

# maybe add ARC and TESTARC too
if ( args.obstype in ['FLAT', 'TESTFLAT', 'SKY', 'TWILIGHT']     )   or
   ( args.obstype in ['SCIENCE',] and (not args.noprestdstarfit) ):
    if rank == 0:
        log.info('Starting extractions at {}'.format(time.asctime()))

    if rank > 0:
        cmds = inputs = outputs = None
    else:
        cmds = dict()
        inputs = dict()
        outputs = dict()
        for camera in args.cameras:
            cmd = 'desi_extract_spectra'
        
            #- Based on data from SM1-SM8, looking at central and edge fibers
            #- with in mind overlapping arc lamps lines
            if camera.startswith('b'):
                cmd += ' -w 3600.0,5800.0,0.8'
            elif camera.startswith('r'):
                cmd += ' -w 5760.0,7620.0,0.8'
            elif camera.startswith('z'):
                cmd += ' -w 7520.0,9824.0,0.8'

            preprocfile = findfile('preproc', args.night, args.expid, camera)
            psffile = findfile('psf', args.night, args.expid, camera)
            framefile = findfile('frame', args.night, args.expid, camera)
            cmd += ' -i {}'.format(preprocfile)
            cmd += ' -p {}'.format(psffile)
            cmd += ' -o {}'.format(framefile)
            cmd += ' --psferr 0.1'
            
            if args.obstype == 'SCIENCE' or args.obstype == 'SKY' :
                if rank == 0:
                    log.info('Include barycentric correction')
                cmd += ' --barycentric-correction'
            
            if not os.path.exists(framefile):
                cmds[camera] = cmd
                inputs[camera] = [preprocfile, psffile]
                outputs[camera] = [framefile,]

    #- TODO: refactor/combine this with PSF comm splitting logic
    if comm is not None:
        cmds = comm.bcast(cmds, root=0)
        inputs = comm.bcast(inputs, root=0)
        outputs = comm.bcast(outputs, root=0)

        #- split communicator by 20 (number of bundles)
        extract_size = 20
        if (rank == 0) and (size%extract_size != 0):
            log.warning('MPI size={} should be evenly divisible by {}'.format(
                size, extract_size))
    
        extract_group = rank // extract_size
        num_extract_groups = (size + extract_size - 1) // extract_size
        comm_extract = comm.Split(color=extract_group)
        
        for i in range(extract_group, len(args.cameras), num_extract_groups):
            camera = args.cameras[i]
            if camera in cmds:
                cmdargs = cmds[camera].split()[1:]
                extract_args = desispec.scripts.extract.parse(cmdargs)
                if comm_extract.rank == 0:
                    print('RUNNING: {}'.format(cmds[camera]))

                desispec.scripts.extract.main_mpi(extract_args, comm=comm_extract)

        comm.barrier()
        
    else:
        log.warning('running extractions without MPI parallelism; this will be SLOW')
        for camera in args.cameras:
            if camera in cmds:
                runcmd(cmds[camera], inputs=inputs[camera], outputs=outputs[camera])

    if comm is not None:
        comm.barrier()

    if rank == 0:
        progress['extract'] = time.asctime()

#-------------------------------------------------------------------------
#- Fiberflat

if args.obstype in ['FLAT', 'TESTFLAT'] :
    if rank == 0:
        log.info('Starting fiberflats at {}'.format(time.asctime()))

    for i in range(rank, len(args.cameras), size):
        camera = args.cameras[i]
        framefile = findfile('frame', args.night, args.expid, camera)
        fiberflatfile = findfile('fiberflat', args.night, args.expid, camera)
        cmd = "desi_compute_fiberflat"
        cmd += " -i {}".format(framefile)
        cmd += " -o {}".format(fiberflatfile)
        runcmd(cmd, inputs=[framefile,], outputs=[fiberflatfile,])

    if comm is not None:
        comm.barrier()

    if rank == 0:
        progress['fiberflat'] = time.asctime()

#-------------------------------------------------------------------------
#- Get input fiberflat
input_fiberflat = dict()
if rank == 0:
    for camera in args.cameras :
        if args.fiberflat is not None :
            input_fiberflat[camera] = args.fiberflat
        elif args.calibnight is not None :
            # look for a fiberflatnight for this calib night
            fiberflatnightfile = findfile('fiberflatnight',
                    args.calibnight, args.expid, camera)
            if not os.path.isfile(fiberflatnightfile) :
                log.error("no {}".format(fiberflatnightfile))
                raise IOError("no {}".format(fiberflatnightfile))
            input_fiberflat[camera] = fiberflatnightfile
        else :
            # look for a fiberflatnight fiberflat
            fiberflatnightfile = findfile('fiberflatnight',
                    args.night, args.expid, camera)
            if os.path.isfile(fiberflatnightfile) :
                input_fiberflat[camera] = fiberflatnightfile
            elif args.most_recent_calib:
                nightfile = find_most_recent(args.night, file_type='fiberflatnight')
                if nightfile is None:
                    input_fiberflat[camera] = findcalibfile([hdr, camhdr[camera]], 'FIBERFLAT')
                else:
                    input_fiberflat[camera] = nightfile
            else :
                input_fiberflat[camera] = findcalibfile(
                        [hdr, camhdr[camera]], 'FIBERFLAT')
        log.info("Will use input FIBERFLAT: {}".format(input_fiberflat[camera]))

if comm is not None:
    input_fiberflat = comm.bcast(input_fiberflat, root=0)

#-------------------------------------------------------------------------
#- Apply fiberflat and write fframe file

if args.obstype in ['SCIENCE', 'SKY'] and args.fframe and ( not args.nofiberflat ):
    if args.obstype in ['SCIENCE',] and args.noprestdstarfit:
        pass
    
    if rank == 0:
        log.info('Applying fiberflat at {}'.format(time.asctime()))

    for i in range(rank, len(args.cameras), size):
        camera = args.cameras[i]
        fframefile = findfile('fframe', args.night, args.expid, camera)
        if not os.path.exists(fframefile):
            framefile = findfile('frame', args.night, args.expid, camera)
            fr = desispec.io.read_frame(framefile)
            flatfilename=input_fiberflat[camera]
            if flatfilename is not None :
                ff = desispec.io.read_fiberflat(flatfilename)
                apply_fiberflat(fr, ff)

                fframefile = findfile('fframe', args.night, args.expid, camera)
                desispec.io.write_frame(fframefile, fr)
            else :
                log.warning("Missing fiberflat for camera {}".format(camera))

    if comm is not None:
        comm.barrier()

    if rank == 0:
        progress['fframe'] = time.asctime()

#-------------------------------------------------------------------------
#- Select random sky fibers (inplace update of frame file)
#- TODO: move this to a function somewhere
#- TODO: this assigns different sky fibers to each frame of same spectrograph

if (args.obstype in ['SKY', 'SCIENCE']) and (not args.noskysub):
    if args.obstype in ['SCIENCE',] and args.noprestdstarfit:
        pass
    
    if rank == 0:
        log.info('Picking sky fibers at {}'.format(time.asctime()))

    for i in range(rank, len(args.cameras), size):
        camera = args.cameras[i]
        framefile = findfile('frame', args.night, args.expid, camera)
        orig_frame = desispec.io.read_frame(framefile)

        #- Make a copy so that we can apply fiberflat
        fr = deepcopy(orig_frame)

        if np.any(fr.fibermap['OBJTYPE'] == 'SKY'):
            log.info('{} sky fibers already set; skipping'.format(
                os.path.basename(framefile)))
            continue

        #- Apply fiberflat then select random fibers below a flux cut
        flatfilename=input_fiberflat[camera]
        if flatfilename is None :
            log.error("No fiberflat for {}".format(camera))
            continue
        ff = desispec.io.read_fiberflat(flatfilename)
        apply_fiberflat(fr, ff)
        sumflux = np.sum(fr.flux, axis=1)
        fluxcut = np.percentile(sumflux, 30)
        iisky = np.where(sumflux < fluxcut)[0]
        iisky = np.random.choice(iisky, size=100, replace=False)

        #- Update fibermap or original frame and write out
        orig_frame.fibermap['OBJTYPE'][iisky] = 'SKY'
        orig_frame.fibermap['DESI_TARGET'][iisky] |= desi_mask.SKY

        desispec.io.write_frame(framefile, orig_frame)

    if comm is not None:
        comm.barrier()

    if rank == 0:
        progress['picksky'] = time.asctime()

#-------------------------------------------------------------------------
#- Sky subtraction
if args.obstype in ['SCIENCE', 'SKY'] and (not args.noskysub ) and (not args.noprestdstarfit):
    if rank == 0:
        log.info('Starting sky subtraction at {}'.format(time.asctime()))

    for i in range(rank, len(args.cameras), size):
        camera = args.cameras[i]
        framefile = findfile('frame', args.night, args.expid, camera)
        hdr = fitsio.read_header(framefile, 'FLUX')
        fiberflatfile=input_fiberflat[camera]
        if fiberflatfile is None :
            log.error("No fiberflat for {}".format(camera))
            continue
        skyfile = findfile('sky', args.night, args.expid, camera)

        cmd = "desi_compute_sky"
        cmd += " -i {}".format(framefile)
        cmd += " --fiberflat {}".format(fiberflatfile)
        cmd += " --o {}".format(skyfile)
        if not args.extra_variance :
            cmd += " --no-extra-variance"

        runcmd(cmd, inputs=[framefile, fiberflatfile], outputs=[skyfile,])

        #- sframe = flatfielded sky-subtracted but not flux calibrated frame
        #- Note: this re-reads and re-does steps previously done for picking
        #- sky fibers; desi_proc is about human efficiency,
        #- not I/O or CPU efficiency...
        sframefile = desispec.io.findfile('sframe', args.night, args.expid, camera)
        if not os.path.exists(sframefile):
            frame = desispec.io.read_frame(framefile)
            fiberflat = desispec.io.read_fiberflat(fiberflatfile)
            sky = desispec.io.read_sky(skyfile)
            apply_fiberflat(frame, fiberflat)
            subtract_sky(frame, sky, apply_throughput_correction=True)
            desispec.io.write_frame(sframefile, frame)

    if comm is not None:
        comm.barrier()

    if rank == 0:
        progress['sky'] = time.asctime()

#-------------------------------------------------------------------------
#- Standard Star Fitting

if args.obstype in ['SCIENCE',] and \
        (not args.noskysub ) and \
        (not args.nostdstarfit ) :

    if rank == 0:
        log.info('Starting standard star fitting at {}'.format(time.asctime()))

    #- Group inputs by spectrograph
    framefiles = dict()
    skyfiles = dict()
    fiberflatfiles = dict()
    night, expid = args.night, args.expid #- shorter
    for camera in args.cameras:
        sp = int(camera[1])
        if sp not in framefiles:
            framefiles[sp] = list()
            skyfiles[sp] = list()
            fiberflatfiles[sp] = list()

        framefiles[sp].append(findfile('frame', night, expid, camera))
        skyfiles[sp].append(findfile('sky', night, expid, camera))
        fiberflatfiles[sp].append(input_fiberflat[camera])

    #- Hardcoded stdstar model version
    starmodels = os.path.join(
            os.getenv('DESI_BASIS_TEMPLATES'), 'stdstar_templates_v2.2.fits')

    #- Fit stdstars per spectrograph (not per-camera)
    spectro_nums = sorted(framefiles.keys())
    ## for sp in spectro_nums[rank::size]:
    for i in range(rank, len(spectro_nums), size):
        sp = spectro_nums[i]

        stdfile = findfile('stdstars', night, expid, spectrograph=sp)
        cmd = "desi_fit_stdstars"
        cmd += " --frames {}".format(' '.join(framefiles[sp]))
        cmd += " --skymodels {}".format(' '.join(skyfiles[sp]))
        cmd += " --fiberflats {}".format(' '.join(fiberflatfiles[sp]))
        cmd += " --starmodels {}".format(starmodels)
        cmd += " --outfile {}".format(stdfile)
        if args.maxstdstars is not None:
            cmd += " --maxstdstars {}".format(args.maxstdstars)

        inputs = framefiles[sp] + skyfiles[sp] + fiberflatfiles[sp]
        runcmd(cmd, inputs=inputs, outputs=[stdfile])

    if comm is not None:
        comm.barrier()

#-------------------------------------------------------------------------                                             
#- Flux calibration

if args.obstype in ['SCIENCE',] and \
        (not args.noskysub ) and \
        (not args.nofluxcalib) :

    if rank == 0:
        log.info('Starting flux calibration at {}'.format(time.asctime()))

    #- Compute flux calibration vectors per camera
    for camera in args.cameras[rank::size]:
        framefile = findfile('frame', night, expid, camera)
        skyfile = findfile('sky', night, expid, camera)
        spectrograph = int(camera[1])
        stdfile = findfile('stdstars', night, expid,spectrograph=spectrograph)
        calibfile = findfile('fluxcalib', night, expid, camera)

        fiberflatfile = input_fiberflat[camera]

        cmd = "desi_compute_fluxcalibration"
        cmd += " --infile {}".format(framefile)
        cmd += " --sky {}".format(skyfile)
        cmd += " --fiberflat {}".format(fiberflatfile)
        cmd += " --models {}".format(stdfile)
        cmd += " --outfile {}".format(calibfile)
        cmd += " --delta-color-cut 0.1"
        
        inputs = [framefile, skyfile, fiberflatfile, stdfile]
        runcmd(cmd, inputs=inputs, outputs=[calibfile,])

    if comm is not None:
        comm.barrier()

    if rank == 0:
        progress['fluxcalib'] = time.asctime()
#-------------------------------------------------------------------------
#- Applying flux calibration

if args.obstype in ['SCIENCE',] and (not args.noskysub ) and (not args.nofluxcalib) :

    night, expid = args.night, args.expid #- shorter

    if rank == 0:
        log.info('Starting cframe file creation at {}'.format(time.asctime()))
    
    for camera in args.cameras[rank::size]:
        framefile = findfile('frame', night, expid, camera)
        skyfile = findfile('sky', night, expid, camera)
        spectrograph = int(camera[1])
        stdfile = findfile('stdstars', night, expid, spectrograph=spectrograph)
        calibfile = findfile('fluxcalib', night, expid, camera)
        cframefile = findfile('cframe', night, expid, camera)

        fiberflatfile = input_fiberflat[camera]

        cmd = "desi_process_exposure"
        cmd += " --infile {}".format(framefile)
        cmd += " --fiberflat {}".format(fiberflatfile)
        cmd += " --sky {}".format(skyfile)
        cmd += " --calib {}".format(calibfile)
        cmd += " --outfile {}".format(cframefile)
        cmd += " --cosmics-nsig 6"

        inputs = [framefile, fiberflatfile, skyfile, calibfile]
        runcmd(cmd, inputs=inputs, outputs=[cframefile,])

    if comm is not None:
        comm.barrier()

    if rank == 0:
        progress['applycalib'] = time.asctime()

#-------------------------------------------------------------------------
#- Wrap up

if rank == 0:
    progress['done'] = time.asctime()

    t0 = None
    print('\nSummary of completion times:')
    for key, value in progress.items():
        if t0 is None:
            print('  {:10s} {}'.format(key, value))
            t0 = time.mktime(time.strptime(value))
        else:
            t1 = time.mktime(time.strptime(value))
            dt = (t1-t0)/60.0
            t0 = t1
            print('  {:10s} {} ({:.1f} min)'.format(key, value, dt))



